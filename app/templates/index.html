{% extends "base.html" %}

{% block content %}
<div class="max-w-2xl mx-auto">
    <!-- Post Composer (shown when logged in) -->
    <div id="composer" class="hidden bg-white sm:rounded-lg shadow mb-2">
        <!-- Collapsed state: single input -->
        <div id="composer-collapsed" class="p-3 cursor-text flex items-center gap-3" onclick="expandComposer()">
            <img id="composer-avatar-collapsed" src="/static/default-avatar.svg" alt="" class="w-10 h-10 rounded-full object-cover bg-gray-200 flex-shrink-0">
            <input type="text" readonly placeholder="What's on your mind?"
                class="w-full px-3 py-2 bg-gray-100 rounded-full text-gray-500 cursor-text">
        </div>
        <!-- Expanded state: full form -->
        <div id="composer-expanded" class="hidden p-4">
            <div class="flex items-start gap-3">
                <img id="composer-avatar-expanded" src="/static/default-avatar.svg" alt="" class="w-10 h-10 rounded-full object-cover bg-gray-200 flex-shrink-0">
                <form id="post-form" class="flex-1">
                    <div class="relative">
                        <textarea id="post-content" rows="9" maxlength="2000"
                            placeholder="What's on your mind?"
                            class="w-full px-3 py-2 pr-8 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-brand-blue resize-none"></textarea>
                        <button type="button" onclick="cancelComposer()" class="absolute top-2 right-2 text-gray-400 hover:text-gray-600">
                            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
                            </svg>
                        </button>
                    </div>
                    <!-- Media preview area -->
                    <div id="media-preview" class="hidden flex flex-wrap gap-2 mt-2">
                    </div>
                    <div class="flex items-center justify-between mt-3">
                        <div class="flex items-center gap-3 flex-wrap">
                            <label class="cursor-pointer text-gray-500 hover:text-brand-blue" title="Add photo or video">
                                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z"/>
                                </svg>
                                <input type="file" id="media-input" accept="image/jpeg,image/png,image/webp,video/mp4,video/webm,video/quicktime" class="hidden" onchange="handleMediaSelect(event)">
                            </label>
                            <select id="post-as" class="hidden text-sm border border-gray-300 rounded-md px-2 py-1 focus:outline-none focus:ring-2 focus:ring-brand-blue" onchange="handlePostAsChange()">
                                <option value="">Yourself</option>
                            </select>
                            <select id="post-visibility" class="text-sm border border-gray-300 rounded-md px-2 py-1 focus:outline-none focus:ring-2 focus:ring-brand-blue">
                                <option value="connections">Connections only</option>
                                <option value="public">Public</option>
                            </select>
                            <span id="post-chars" class="text-xs text-gray-500">0/2000</span>
                        </div>
                        <button type="submit" id="post-submit" disabled class="px-4 py-2 bg-brand-blue text-white rounded-md hover:opacity-90 disabled:opacity-50 disabled:cursor-not-allowed">
                            Post
                        </button>
                    </div>
                </form>
            </div>
        </div>
    </div>

    <!-- Filter Tabs (shown when logged in) -->
    <div id="feed-tabs" class="hidden flex border-b border-gray-200 bg-white sm:rounded-t-lg mb-0">
        <button onclick="switchFilter('all')" id="tab-all" class="flex-1 py-3 text-sm font-medium border-b-2 border-brand-blue text-brand-blue">
            Feed
        </button>
        <button onclick="switchFilter('mine')" id="tab-mine" class="flex-1 py-3 text-sm font-medium border-b-2 border-transparent text-gray-500 hover:text-gray-700">
            My Posts
        </button>
    </div>

    <!-- Feed Posts -->
    <div id="feed-container" class="hidden">
        <div id="posts-list" class="space-y-2"></div>
        <div id="loading-more" class="hidden py-4 text-center">
            <span class="text-gray-500">Loading...</span>
        </div>
        <div id="no-posts" class="hidden bg-white sm:rounded-lg shadow p-8 text-center">
            <p class="text-gray-500">No posts to show.</p>
        </div>
        <div id="end-of-feed" class="hidden py-4 text-center">
            <span class="text-gray-400 text-sm">You've reached the end</span>
        </div>
    </div>
</div>

<!-- Delete Confirmation Modal -->
<div id="delete-modal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
    <div class="bg-white rounded-lg shadow-xl w-full max-w-sm mx-4 p-6">
        <h3 class="text-lg font-semibold mb-4">Delete Post?</h3>
        <p class="text-gray-600 mb-6">This will permanently delete this post and all its comments.</p>
        <div class="flex justify-end gap-3">
            <button onclick="hideDeleteModal()" class="px-4 py-2 border border-gray-300 text-gray-700 rounded-md hover:bg-gray-50">
                Cancel
            </button>
            <button onclick="confirmDelete()" class="px-4 py-2 bg-red-600 text-white rounded-md hover:opacity-90">
                Delete
            </button>
        </div>
    </div>
</div>

<script src="/static/js/posts.js"></script>
<script>
    let currentFilter = 'all';
    let isLoading = false;
    let hasMore = true;
    let lastPostId = null;
    let currentUserId = null;
    let deletePostId = null; // For delete confirmation
    let pendingMedia = []; // Files selected for upload
    let expandedPosts = new Set(); // Track which posts have comments expanded
    let loadedComments = {}; // Cache loaded comments by post ID
    let replyingTo = {}; // Track which comment we're replying to: { rootPostId: commentId }
    let userPages = []; // Pages the user can post as (owner or editor)
    const COMMENT_TRUNCATE_LENGTH = 280; // Characters before truncating
    // defaultPageIcons is provided by /static/js/posts.js

    const composerPlaceholders = [
        "What's on your mind?",
        "Share something!",
        "What are you working on?",
        "Got something to share?",
        "What's new with you?",
        "Share an update...",
        "What have you learned lately?",
        "Any wins to celebrate?",
        "What's inspiring you today?",
    ];

    function getRandomPlaceholder() {
        return composerPlaceholders[Math.floor(Math.random() * composerPlaceholders.length)];
    }

    function isTokenValid(token) {
        if (!token) return false;
        try {
            const base64Url = token.split('.')[1];
            const base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/');
            const payload = JSON.parse(window.atob(base64));
            return payload && payload.exp * 1000 > Date.now();
        } catch (e) {
            return false;
        }
    }

    async function init() {
        const token = localStorage.getItem('token');
        const isLoggedIn = isTokenValid(token);

        if (isLoggedIn) {
            document.getElementById('composer').classList.remove('hidden');
            document.getElementById('feed-tabs').classList.remove('hidden');
            document.getElementById('feed-container').classList.remove('hidden');

            // Set random placeholder
            const placeholder = getRandomPlaceholder();
            document.querySelector('#composer-collapsed input').placeholder = placeholder;
            document.getElementById('post-content').placeholder = placeholder;

            // Get current user info and pages in parallel
            try {
                const [meResponse, pagesResponse] = await Promise.all([
                    fetch('/api/me', { headers: { 'Authorization': `Bearer ${token}` } }),
                    fetch('/api/pages/my', { headers: { 'Authorization': `Bearer ${token}` } })
                ]);

                if (meResponse.ok) {
                    const me = await meResponse.json();
                    currentUserId = me.id;
                    // Set composer avatars
                    if (me.avatar_url) {
                        document.getElementById('composer-avatar-collapsed').src = me.avatar_url;
                        document.getElementById('composer-avatar-expanded').src = me.avatar_url;
                    }
                }

                if (pagesResponse.ok) {
                    userPages = await pagesResponse.json();
                    // Check for post_as query parameter
                    const urlParams = new URLSearchParams(window.location.search);
                    const postAsHandle = urlParams.get('post_as');
                    populatePostAsDropdown(postAsHandle);

                    // If post_as is set and valid, expand composer
                    if (postAsHandle && userPages.some(p => p.handle === postAsHandle)) {
                        expandComposer();
                    }
                }
            } catch (e) {
                console.error('Failed to get user:', e);
            }

            await loadPosts();
            setupInfiniteScroll();
        } else {
            // Show public posts for guests
            document.getElementById('feed-container').classList.remove('hidden');
            document.getElementById('feed-tabs').classList.add('hidden');
            await loadPosts();
            setupInfiniteScroll();
        }
    }

    function switchFilter(filter) {
        currentFilter = filter;
        lastPostId = null;
        hasMore = true;

        // Update tab styles
        ['all', 'mine'].forEach(f => {
            const tab = document.getElementById(`tab-${f}`);
            if (f === filter) {
                tab.classList.add('border-brand-blue', 'text-brand-blue');
                tab.classList.remove('border-transparent', 'text-gray-500');
            } else {
                tab.classList.remove('border-brand-blue', 'text-brand-blue');
                tab.classList.add('border-transparent', 'text-gray-500');
            }
        });

        document.getElementById('posts-list').innerHTML = '';
        loadPosts();
    }

    async function loadPosts(append = false) {
        if (isLoading) return;
        isLoading = true;

        const token = localStorage.getItem('token');
        const loading = document.getElementById('loading-more');
        const noPosts = document.getElementById('no-posts');
        const endOfFeed = document.getElementById('end-of-feed');

        loading.classList.remove('hidden');
        noPosts.classList.add('hidden');
        endOfFeed.classList.add('hidden');

        try {
            let url = `/api/posts?filter=${currentFilter}&limit=20`;
            if (lastPostId && append) {
                url += `&before_id=${lastPostId}`;
            }

            const headers = token ? { 'Authorization': `Bearer ${token}` } : {};
            const response = await fetch(url, { headers });

            if (!response.ok) {
                throw new Error('Failed to load posts');
            }

            const data = await response.json();
            hasMore = data.has_more;

            const postsList = document.getElementById('posts-list');

            if (data.posts.length === 0 && !append) {
                noPosts.classList.remove('hidden');
            } else {
                const postsHtml = data.posts.map(post => renderPost(post, { currentUserVotes })).join('');
                if (append) {
                    postsList.insertAdjacentHTML('beforeend', postsHtml);
                } else {
                    postsList.innerHTML = postsHtml;
                }

                if (data.posts.length > 0) {
                    lastPostId = data.posts[data.posts.length - 1].id;
                }

                if (!hasMore) {
                    endOfFeed.classList.remove('hidden');
                }
            }
        } catch (e) {
            console.error('Failed to load posts:', e);
        } finally {
            loading.classList.add('hidden');
            isLoading = false;
        }
    }

    // Uses shared functions from /static/js/posts.js:
    // - renderScaleIcon, renderVotePicker, SCALE_COLORS, getScaleColor
    // - renderPost, renderVisibilityIcon, renderPostMenu
    // - togglePostMenu, closePostMenu, sharePost

    // All shared functions are provided by /static/js/posts.js:
    // formatTime, escapeHtml, formatPostContent, renderPostMedia, openImageModal
    // TEXT_EMOJIS, convertTextEmojis (used internally by formatPostContent)

    function setupInfiniteScroll() {
        window.addEventListener('scroll', () => {
            if (isLoading || !hasMore) return;

            const scrollY = window.scrollY;
            const windowHeight = window.innerHeight;
            const docHeight = document.documentElement.scrollHeight;

            if (scrollY + windowHeight >= docHeight - 200) {
                loadPosts(true);
            }
        });
    }

    function populatePostAsDropdown(preSelectHandle = null) {
        const select = document.getElementById('post-as');
        if (!select) return;

        // Only show if user has pages
        if (userPages.length === 0) {
            select.classList.add('hidden');
            return;
        }

        // Show the dropdown
        select.classList.remove('hidden');

        // Populate options
        select.innerHTML = '<option value="">Yourself</option>' +
            userPages.map(page =>
                `<option value="${page.id}">${escapeHtml(page.name)}</option>`
            ).join('');

        // Pre-select page if handle provided
        if (preSelectHandle) {
            const page = userPages.find(p => p.handle === preSelectHandle);
            if (page) {
                select.value = page.id;
                handlePostAsChange(); // Update visibility dropdown state
            }
        }
    }

    function handlePostAsChange() {
        const postAs = document.getElementById('post-as').value;
        const visibilitySelect = document.getElementById('post-visibility');

        if (postAs) {
            // Posting as a page - always public, hide visibility dropdown
            visibilitySelect.classList.add('hidden');
            visibilitySelect.value = 'public';
        } else {
            // Posting as yourself - show visibility dropdown, default to connections
            visibilitySelect.classList.remove('hidden');
            visibilitySelect.value = 'connections';
        }
    }

    // Composer expand/collapse
    function expandComposer() {
        document.getElementById('composer-collapsed').classList.add('hidden');
        document.getElementById('composer-expanded').classList.remove('hidden');
        document.getElementById('post-content').focus();
    }

    function collapseComposer() {
        const content = document.getElementById('post-content').value.trim();
        if (content) return; // Don't collapse if there's content
        document.getElementById('composer-expanded').classList.add('hidden');
        document.getElementById('composer-collapsed').classList.remove('hidden');
    }

    function cancelComposer() {
        document.getElementById('post-content').value = '';
        document.getElementById('post-chars').textContent = '0/2000';
        // Reset post-as dropdown
        const postAsSelect = document.getElementById('post-as');
        if (postAsSelect) postAsSelect.value = '';
        clearPendingMedia();
        document.getElementById('composer-expanded').classList.add('hidden');
        document.getElementById('composer-collapsed').classList.remove('hidden');
    }

    // Media handling
    const ALLOWED_IMAGE_TYPES = ['image/jpeg', 'image/png', 'image/webp'];
    const ALLOWED_VIDEO_TYPES = ['video/mp4', 'video/webm', 'video/quicktime'];
    const MAX_IMAGE_SIZE = 5 * 1024 * 1024; // 5MB
    const MAX_VIDEO_SIZE = 100 * 1024 * 1024; // 100MB

    function handleMediaSelect(event) {
        const files = Array.from(event.target.files);

        // Only allow 1 media per post
        if (pendingMedia.length >= 1) {
            alert('Maximum 1 media per post');
            event.target.value = '';
            return;
        }

        const file = files[0];
        if (!file) return;

        const isImage = ALLOWED_IMAGE_TYPES.includes(file.type);
        const isVideo = ALLOWED_VIDEO_TYPES.includes(file.type);

        if (!isImage && !isVideo) {
            alert('Only JPEG, PNG, WebP images or MP4, WebM, MOV videos allowed');
            event.target.value = '';
            return;
        }

        const maxSize = isVideo ? MAX_VIDEO_SIZE : MAX_IMAGE_SIZE;
        if (file.size > maxSize) {
            alert(`File too large (max ${isVideo ? '100MB' : '5MB'})`);
            event.target.value = '';
            return;
        }

        pendingMedia = [file];

        // Clear input for re-selection
        event.target.value = '';
        renderMediaPreviews();
    }

    function renderMediaPreviews() {
        const container = document.getElementById('media-preview');
        if (pendingMedia.length === 0) {
            container.classList.add('hidden');
            container.innerHTML = '';
            updatePostButtonState();
            return;
        }

        container.classList.remove('hidden');
        container.innerHTML = pendingMedia.map((file, index) => {
            const url = URL.createObjectURL(file);
            const isVideo = file.type.startsWith('video/');
            const mediaEl = isVideo
                ? `<video src="${url}" class="w-20 h-20 object-cover rounded-lg"></video>`
                : `<img src="${url}" alt="" class="w-20 h-20 object-cover rounded-lg">`;
            return `
                <div class="relative">
                    ${mediaEl}
                    ${isVideo ? '<div class="absolute inset-0 flex items-center justify-center pointer-events-none"><span class="text-white text-2xl bg-black bg-opacity-50 rounded-full w-8 h-8 flex items-center justify-center">â–¶</span></div>' : ''}
                    <button type="button" onclick="removePendingMedia(${index})" class="absolute -top-2 -right-2 w-5 h-5 bg-gray-800 text-white rounded-full flex items-center justify-center text-xs hover:bg-red-600">
                        &times;
                    </button>
                </div>
            `;
        }).join('');
        updatePostButtonState();
    }

    function removePendingMedia(index) {
        pendingMedia.splice(index, 1);
        renderMediaPreviews();
    }

    function clearPendingMedia() {
        pendingMedia = [];
        document.getElementById('media-preview').classList.add('hidden');
        document.getElementById('media-preview').innerHTML = '';
        updatePostButtonState();
    }

    async function uploadMediaForPost(postId, token) {
        for (let i = 0; i < pendingMedia.length; i++) {
            const file = pendingMedia[i];
            try {
                // Step 1: Get presigned URL from server
                const urlRes = await fetch(`/api/posts/${postId}/media/upload-url`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${token}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ content_type: file.type, index: i })
                });
                if (!urlRes.ok) throw new Error('Failed to get upload URL');
                const { upload_url, media_path } = await urlRes.json();

                // Step 2: Upload directly to R2
                const uploadRes = await fetch(upload_url, {
                    method: 'PUT',
                    headers: { 'Content-Type': file.type },
                    body: file
                });
                if (!uploadRes.ok) throw new Error('Failed to upload to R2');

                // Step 3: Confirm upload with server
                await fetch(`/api/posts/${postId}/media/confirm`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${token}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ media_path, content_type: file.type })
                });
            } catch (e) {
                console.error('Failed to upload media:', e);
            }
        }
    }

    // Collapse when clicking outside composer
    document.addEventListener('click', (e) => {
        const composer = document.getElementById('composer');
        const expanded = document.getElementById('composer-expanded');
        if (!composer.contains(e.target) && !expanded.classList.contains('hidden')) {
            collapseComposer();
        }
    });

    // Post form
    function updatePostButtonState() {
        const content = document.getElementById('post-content').value.trim();
        document.getElementById('post-submit').disabled = content.length === 0;
    }

    document.getElementById('post-content').addEventListener('input', (e) => {
        document.getElementById('post-chars').textContent = `${e.target.value.length}/2000`;
        updatePostButtonState();
    });

    document.getElementById('post-form').addEventListener('submit', async (e) => {
        e.preventDefault();
        const content = document.getElementById('post-content').value.trim();
        const visibility = document.getElementById('post-visibility').value;
        const postAsSelect = document.getElementById('post-as');
        const pageId = postAsSelect && postAsSelect.value ? parseInt(postAsSelect.value) : null;

        if (!content && pendingMedia.length === 0) return;

        const token = localStorage.getItem('token');
        if (!token) {
            window.location.href = '/login';
            return;
        }

        try {
            const postData = { content: content || ' ', visibility };
            if (pageId) {
                postData.page_id = pageId;
            }

            const response = await fetch('/api/posts', {
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${token}`,
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(postData)
            });

            if (response.ok) {
                const result = await response.json();

                // Upload any pending media
                if (pendingMedia.length > 0) {
                    await uploadMediaForPost(result.id, token);
                }

                document.getElementById('post-content').value = '';
                document.getElementById('post-chars').textContent = '0/2000';
                // Reset post-as dropdown
                const postAsSelect = document.getElementById('post-as');
                if (postAsSelect) postAsSelect.value = '';
                clearPendingMedia();
                collapseComposer();
                // Reload feed to show new post
                lastPostId = null;
                hasMore = true;
                await loadPosts();
            } else {
                const error = await response.json();
                const message = typeof error.detail === 'string' ? error.detail : 'Failed to create post';
                alert(message);
            }
        } catch (e) {
            console.error('Failed to create post:', e);
            alert('Failed to create post');
        }
    });

    // Scale Voting System
    let currentUserVotes = {}; // Track user's votes per post

    function toggleVotePicker(postId, event) {
        event.stopPropagation();
        const picker = document.getElementById(`vote-picker-${postId}`);
        if (!picker) return;

        // Close any other open pickers
        document.querySelectorAll('[id^="vote-picker-"]').forEach(p => {
            if (p.id !== `vote-picker-${postId}`) {
                p.classList.add('hidden');
            }
        });

        if (picker.classList.contains('hidden')) {
            picker.innerHTML = renderVotePicker(postId, currentUserVotes[postId] ?? null);
            picker.classList.remove('hidden');

            // Close picker when clicking outside
            const closeHandler = (e) => {
                if (!picker.contains(e.target) && !e.target.closest(`#vote-container-${postId}`)) {
                    picker.classList.add('hidden');
                    document.removeEventListener('click', closeHandler);
                }
            };
            setTimeout(() => document.addEventListener('click', closeHandler), 0);
        } else {
            picker.classList.add('hidden');
        }
    }

    async function submitVote(postId, value, event) {
        event.stopPropagation();

        const token = localStorage.getItem('token');
        if (!token) {
            window.location.href = '/login';
            return;
        }

        try {
            let response;
            if (value === null) {
                // Remove vote via DELETE
                response = await fetch(`/api/posts/${postId}/vote`, {
                    method: 'DELETE',
                    headers: {
                        'Authorization': `Bearer ${token}`
                    }
                });
            } else {
                // Submit vote via POST
                response = await fetch(`/api/posts/${postId}/vote`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${token}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ value })
                });
            }

            if (response.ok) {
                const data = await response.json();
                updateScaleDisplay(postId, data);
                // Close picker
                document.getElementById(`vote-picker-${postId}`).classList.add('hidden');
            }
        } catch (e) {
            console.error('Failed to vote:', e);
        }
    }

    function updateScaleDisplay(postId, data) {
        // Update current user's vote
        currentUserVotes[postId] = data.user_vote;

        // Update scale icon and ring indicator
        const iconEl = document.getElementById(`scale-icon-${postId}`);
        if (iconEl) {
            iconEl.innerHTML = renderScaleIcon(data.display_level, 24);
            if (data.user_vote !== null) {
                iconEl.className = 'ring-2 ring-brand-blue ring-offset-1 rounded-full';
            } else {
                iconEl.className = '';
            }
        }

        // Update vote count (always show)
        const countEl = document.getElementById(`vote-count-${postId}`);
        if (countEl) {
            countEl.textContent = data.vote_count;
        }
    }

    // Inline Comments System
    async function toggleComments(postId) {
        const section = document.getElementById(`comments-section-${postId}`);

        if (expandedPosts.has(postId)) {
            // Collapse
            section.classList.add('hidden');
            expandedPosts.delete(postId);
        } else {
            // Expand
            section.classList.remove('hidden');
            expandedPosts.add(postId);

            // Load comments if not cached
            if (!loadedComments[postId]) {
                section.innerHTML = '<div class="p-4 text-center text-gray-500">Loading...</div>';
                await loadComments(postId);
            } else {
                renderCommentsSection(postId, loadedComments[postId]);
            }
        }
    }

    async function loadComments(postId) {
        const token = localStorage.getItem('token');
        const headers = token ? { 'Authorization': `Bearer ${token}` } : {};

        try {
            const response = await fetch(`/api/posts/${postId}`, { headers });
            if (!response.ok) {
                console.error('Failed to load comments');
                return;
            }

            const data = await response.json();
            loadedComments[postId] = data.comments;
            renderCommentsSection(postId, data.comments);
        } catch (e) {
            console.error('Failed to load comments:', e);
        }
    }

    function renderCommentsSection(postId, comments) {
        const section = document.getElementById(`comments-section-${postId}`);
        const token = localStorage.getItem('token');

        let html = '<div class="divide-y divide-gray-100">';

        if (comments.length === 0) {
            html += '<div class="p-4 text-center text-gray-500 text-sm">No comments yet</div>';
        } else {
            comments.forEach(comment => {
                html += renderComment(comment, postId, comments);
            });
        }

        html += '</div>';

        // Reply form
        if (token) {
            html += `
                <div class="p-3 border-t border-gray-100">
                    <div id="reply-indicator-${postId}" class="hidden text-xs text-brand-blue mb-2 flex items-center"></div>
                    <form onsubmit="submitReply(event, ${postId})" class="flex gap-2">
                        <input type="text" id="reply-input-${postId}" placeholder="Write a comment..." maxlength="2000"
                            class="flex-1 px-3 py-2 border border-gray-300 rounded-full text-sm focus:outline-none focus:ring-2 focus:ring-brand-blue">
                        <button type="submit" class="px-4 py-2 bg-brand-blue text-white rounded-full hover:opacity-90 text-sm">
                            Reply
                        </button>
                    </form>
                </div>
            `;
        }

        section.innerHTML = html;
    }

    function renderComment(comment, rootPostId, allComments) {
        const authorUrl = `/u/${comment.author.handle}`;
        const avatarUrl = comment.author.avatar_url || '/static/default-avatar.svg';
        const timeStr = formatTime(comment.created_at);

        // Track user's vote for this comment
        if (comment.user_vote !== null) {
            currentUserVotes[comment.id] = comment.user_vote;
        }

        const token = localStorage.getItem('token');
        const canVote = token && !comment.is_mine;
        const voteButtonClass = canVote ? 'hover:opacity-80 cursor-pointer' : 'cursor-default';

        // Three dots menu with Delete (if own) and Report Abuse
        const menuItems = [];
        if (comment.is_mine) {
            menuItems.push(`<button onclick="showDeleteModal(${comment.id}, ${rootPostId}); closeCommentMenu(${comment.id})" class="w-full text-left px-4 py-2 text-gray-700 hover:bg-gray-100">Delete</button>`);
        }
        if (token && !comment.is_mine) {
            menuItems.push(`<button onclick="reportAbuse(${comment.id}); closeCommentMenu(${comment.id})" class="w-full text-left px-4 py-2 text-gray-700 hover:bg-gray-100">Report Abuse</button>`);
        }

        const commentMenu = menuItems.length > 0 ? `
            <div class="relative ml-auto">
                <button onclick="toggleCommentMenu(${comment.id}, event)" class="text-gray-400 hover:text-gray-600 p-1">
                    <svg class="w-4 h-4" fill="currentColor" viewBox="0 0 20 20">
                        <path d="M10 6a2 2 0 110-4 2 2 0 010 4zM10 12a2 2 0 110-4 2 2 0 010 4zM10 18a2 2 0 110-4 2 2 0 010 4z"/>
                    </svg>
                </button>
                <div id="comment-menu-${comment.id}" class="hidden absolute right-0 top-full mt-1 w-36 bg-white rounded-lg shadow-lg border border-gray-200 py-1 z-50">
                    ${menuItems.join('')}
                </div>
            </div>
        ` : '';

        // Check if this is a reply to another comment (not the root post)
        let replyToButton = '';
        if (comment.reply_to_id && comment.reply_to_id !== rootPostId) {
            // Find the parent comment
            const parentComment = allComments.find(c => c.id === comment.reply_to_id);
            if (parentComment) {
                replyToButton = `<button onclick="scrollToComment(${comment.reply_to_id})" class="text-brand-blue hover:underline flex items-center justify-center w-6 h-6" title="Jump to parent comment">
                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20 20h-8v-16M12 4l-4 4m4-4l4 4"/>
                    </svg>
                </button>`;
            }
        }

        // Truncate long comments
        const content = comment.content || '';
        const isTruncated = content.length > COMMENT_TRUNCATE_LENGTH;
        const displayContent = isTruncated
            ? content.substring(0, COMMENT_TRUNCATE_LENGTH) + '...'
            : content;
        const showMoreButton = isTruncated
            ? `<button onclick="expandComment(${comment.id})" class="text-brand-blue hover:underline text-xs" id="expand-btn-${comment.id}">show more</button>`
            : '';

        return `
            <div class="p-3 hover:bg-gray-50" id="comment-${comment.id}" data-post-id="${comment.id}">
                <div class="flex items-start gap-2">
                    ${replyToButton ? `<div class="flex-shrink-0 pt-1">${replyToButton}</div>` : ''}
                    <a href="${authorUrl}" class="flex-shrink-0">
                        <img src="${avatarUrl}" alt="" class="w-8 h-8 rounded-full object-cover bg-gray-200">
                    </a>
                    <div class="flex-1 min-w-0">
                        <div class="flex items-center gap-2 flex-wrap text-sm">
                            <a href="${authorUrl}" class="font-medium text-gray-900 hover:underline">${escapeHtml(comment.author.name || comment.author.handle)}</a>
                            <span class="text-gray-400 text-xs">${timeStr}</span>
                            ${commentMenu}
                        </div>
                        <p class="text-gray-800 mt-1 whitespace-pre-wrap break-words text-sm" id="content-${comment.id}" data-full="${escapeHtml(content)}">${formatPostContent(displayContent)}</p>
                        ${showMoreButton}
                        <div class="flex items-center gap-3 mt-2 text-xs">
                            <div class="relative" id="vote-container-${comment.id}">
                                <button class="flex items-center gap-1 ${voteButtonClass}" ${canVote ? `onclick="toggleVotePicker(${comment.id}, event)"` : ''}>
                                    <span id="scale-icon-${comment.id}" class="${comment.user_vote !== null ? 'ring-2 ring-brand-blue ring-offset-1 rounded-full' : ''}">${renderScaleIcon(comment.display_level || 0, 20)}</span>
                                    <span id="vote-count-${comment.id}" class="text-gray-500">${comment.vote_count}</span>
                                </button>
                                <div id="vote-picker-${comment.id}" class="hidden"></div>
                            </div>
                            ${token ? `<button onclick="replyToComment(${rootPostId}, ${comment.id})" class="text-gray-500 hover:text-brand-blue">Reply</button>` : ''}
                        </div>
                    </div>
                </div>
            </div>
        `;
    }

    function expandComment(commentId) {
        const contentEl = document.getElementById(`content-${commentId}`);
        const expandBtn = document.getElementById(`expand-btn-${commentId}`);
        if (contentEl && expandBtn) {
            const fullContent = contentEl.dataset.full;
            contentEl.innerHTML = formatPostContent(fullContent);
            expandBtn.remove();
        }
    }

    function scrollToComment(commentId) {
        const commentEl = document.getElementById(`comment-${commentId}`);
        if (commentEl) {
            commentEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
            // Highlight briefly
            commentEl.classList.add('bg-yellow-50');
            setTimeout(() => {
                commentEl.classList.remove('bg-yellow-50');
            }, 1500);
        }
    }

    async function submitReply(event, rootPostId) {
        event.preventDefault();

        const input = document.getElementById(`reply-input-${rootPostId}`);
        const content = input.value.trim();
        if (!content) return;

        const token = localStorage.getItem('token');
        if (!token) {
            window.location.href = '/login';
            return;
        }

        // Determine what we're replying to (a comment or the root post)
        const targetId = replyingTo[rootPostId] || rootPostId;

        try {
            const response = await fetch(`/api/posts/${targetId}/reply`, {
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${token}`,
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ content })
            });

            if (response.ok) {
                input.value = '';
                // Clear reply target
                delete replyingTo[rootPostId];
                clearReplyIndicator(rootPostId);
                // Clear cache and reload comments
                delete loadedComments[rootPostId];
                await loadComments(rootPostId);
                // Update comment count
                const countEl = document.getElementById(`comment-count-${rootPostId}`);
                if (countEl) {
                    countEl.textContent = parseInt(countEl.textContent) + 1;
                }
            } else {
                const error = await response.json();
                alert(error.detail || 'Failed to post comment');
            }
        } catch (e) {
            console.error('Failed to post comment:', e);
            alert('Failed to post comment');
        }
    }

    function replyToComment(rootPostId, commentId) {
        replyingTo[rootPostId] = commentId;
        const input = document.getElementById(`reply-input-${rootPostId}`);
        if (input) {
            input.focus();
            // Show reply indicator
            showReplyIndicator(rootPostId);
        }
    }

    function showReplyIndicator(rootPostId) {
        const indicator = document.getElementById(`reply-indicator-${rootPostId}`);
        if (indicator) {
            indicator.innerHTML = `Replying <button onclick="cancelReplyTo(${rootPostId})" class="text-gray-400 hover:text-gray-600 ml-1">&times;</button>`;
            indicator.classList.remove('hidden');
        }
    }

    function clearReplyIndicator(rootPostId) {
        const indicator = document.getElementById(`reply-indicator-${rootPostId}`);
        if (indicator) {
            indicator.classList.add('hidden');
            indicator.innerHTML = '';
        }
    }

    function cancelReplyTo(rootPostId) {
        delete replyingTo[rootPostId];
        clearReplyIndicator(rootPostId);
        const input = document.getElementById(`reply-input-${rootPostId}`);
        if (input) {
            input.value = '';
        }
    }

    // Delete modal
    let deleteRootPostId = null; // Root post ID for comment deletion refresh

    function showDeleteModal(postId, rootPostId = null) {
        deletePostId = postId;
        deleteRootPostId = rootPostId;
        document.getElementById('delete-modal').classList.remove('hidden');
    }

    function hideDeleteModal() {
        deletePostId = null;
        deleteRootPostId = null;
        document.getElementById('delete-modal').classList.add('hidden');
    }

    async function confirmDelete() {
        if (!deletePostId) return;

        const token = localStorage.getItem('token');
        if (!token) return;

        try {
            const response = await fetch(`/api/posts/${deletePostId}`, {
                method: 'DELETE',
                headers: { 'Authorization': `Bearer ${token}` }
            });

            if (response.ok) {
                const wasComment = deleteRootPostId !== null;
                const rootId = deleteRootPostId;
                hideDeleteModal();

                if (wasComment && rootId) {
                    // Refresh comments for the root post
                    delete loadedComments[rootId];
                    await loadComments(rootId);
                    // Update comment count
                    const countEl = document.getElementById(`comment-count-${rootId}`);
                    if (countEl) {
                        countEl.textContent = Math.max(0, parseInt(countEl.textContent) - 1);
                    }
                } else {
                    // Refresh feed for post deletion
                    lastPostId = null;
                    hasMore = true;
                    await loadPosts();
                }
            } else {
                const error = await response.json();
                alert(error.detail || 'Failed to delete');
            }
        } catch (e) {
            console.error('Failed to delete:', e);
            alert('Failed to delete');
        }
    }

    // Comment menu functions
    function toggleCommentMenu(commentId, event) {
        event.stopPropagation();
        // Close all other menus first
        document.querySelectorAll('[id^="comment-menu-"]').forEach(menu => {
            if (menu.id !== `comment-menu-${commentId}`) {
                menu.classList.add('hidden');
            }
        });
        const menu = document.getElementById(`comment-menu-${commentId}`);
        if (menu) {
            menu.classList.toggle('hidden');
        }
    }

    function closeCommentMenu(commentId) {
        const menu = document.getElementById(`comment-menu-${commentId}`);
        if (menu) {
            menu.classList.add('hidden');
        }
    }

    // Post menu functions (togglePostMenu, closePostMenu, sharePost) are provided by /static/js/posts.js
    // Close menus when clicking outside is also provided by /static/js/posts.js

    async function reportAbuse(postId) {
        const token = localStorage.getItem('token');
        if (!token) {
            window.location.href = '/login';
            return;
        }

        if (!confirm('Report this content for abuse? Our team will review it.')) {
            return;
        }

        try {
            const response = await fetch(`/api/posts/${postId}/report`, {
                method: 'POST',
                headers: { 'Authorization': `Bearer ${token}` }
            });

            if (response.ok) {
                alert('Report submitted. Thank you for helping keep JustPros clean.');
            } else {
                const error = await response.json();
                alert(error.detail || 'Failed to submit report');
            }
        } catch (e) {
            console.error('Failed to report:', e);
            alert('Failed to submit report');
        }
    }

    // ESC key to close modals
    document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
            // Close all menus
            document.querySelectorAll('[id^="comment-menu-"], [id^="post-menu-"]').forEach(menu => {
                menu.classList.add('hidden');
            });
            const imageModal = document.getElementById('image-modal');
            if (imageModal) {
                imageModal.remove();
            } else if (!document.getElementById('delete-modal').classList.contains('hidden')) {
                hideDeleteModal();
            }
        }
    });

    init();
</script>
{% endblock %}
