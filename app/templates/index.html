{% extends "base.html" %}

{% block content %}
<div class="max-w-2xl mx-auto">
    <!-- Post Composer (shown when logged in) -->
    <div id="composer" class="hidden bg-white sm:rounded-lg shadow mb-2">
        <!-- Collapsed state: single input -->
        <div id="composer-collapsed" class="p-3 cursor-text flex items-center gap-3" onclick="expandComposer()">
            <img id="composer-avatar-collapsed" src="/static/default-avatar.svg" alt="" class="w-10 h-10 rounded-full object-cover bg-gray-200 flex-shrink-0">
            <input type="text" readonly placeholder="What's on your mind?"
                class="w-full px-3 py-2 bg-gray-100 rounded-full text-gray-500 cursor-text">
        </div>
        <!-- Expanded state: full form -->
        <div id="composer-expanded" class="hidden p-4">
            <div class="flex items-start gap-3">
                <img id="composer-avatar-expanded" src="/static/default-avatar.svg" alt="" class="w-10 h-10 rounded-full object-cover bg-gray-200 flex-shrink-0">
                <form id="post-form" class="flex-1">
                    <div class="relative">
                        <textarea id="post-content" rows="9" maxlength="2000"
                            placeholder="What's on your mind?"
                            class="w-full px-3 py-2 pr-8 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-brand-blue resize-none"></textarea>
                        <button type="button" onclick="cancelComposer()" class="absolute top-2 right-2 text-gray-400 hover:text-gray-600">
                            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
                            </svg>
                        </button>
                    </div>
                    <!-- Media preview area -->
                    <div id="media-preview" class="hidden flex flex-wrap gap-2 mt-2">
                    </div>
                    <div class="flex items-center justify-between mt-3">
                        <div class="flex items-center gap-3">
                            <label class="cursor-pointer text-gray-500 hover:text-brand-blue" title="Add photo or video">
                                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z"/>
                                </svg>
                                <input type="file" id="media-input" accept="image/jpeg,image/png,image/webp,video/mp4,video/webm,video/quicktime" class="hidden" onchange="handleMediaSelect(event)">
                            </label>
                            <select id="post-visibility" class="text-sm border border-gray-300 rounded-md px-2 py-1 focus:outline-none focus:ring-2 focus:ring-brand-blue">
                                <option value="connections">Connections only</option>
                                <option value="public">Public</option>
                            </select>
                            <span id="post-chars" class="text-xs text-gray-500">0/2000</span>
                        </div>
                        <button type="submit" id="post-submit" disabled class="px-4 py-2 bg-brand-blue text-white rounded-md hover:opacity-90 disabled:opacity-50 disabled:cursor-not-allowed">
                            Post
                        </button>
                    </div>
                </form>
            </div>
        </div>
    </div>

    <!-- Filter Tabs (shown when logged in) -->
    <div id="feed-tabs" class="hidden flex border-b border-gray-200 bg-white sm:rounded-t-lg mb-0">
        <button onclick="switchFilter('all')" id="tab-all" class="flex-1 py-3 text-sm font-medium border-b-2 border-brand-blue text-brand-blue">
            Feed
        </button>
        <button onclick="switchFilter('mine')" id="tab-mine" class="flex-1 py-3 text-sm font-medium border-b-2 border-transparent text-gray-500 hover:text-gray-700">
            My Posts
        </button>
    </div>

    <!-- Feed Posts -->
    <div id="feed-container" class="hidden">
        <div id="posts-list" class="space-y-2"></div>
        <div id="loading-more" class="hidden py-4 text-center">
            <span class="text-gray-500">Loading...</span>
        </div>
        <div id="no-posts" class="hidden bg-white sm:rounded-lg shadow p-8 text-center">
            <p class="text-gray-500">No posts to show.</p>
            <p class="text-gray-400 text-sm mt-2">Connect with people to see their posts, or make your first post!</p>
        </div>
        <div id="end-of-feed" class="hidden py-4 text-center">
            <span class="text-gray-400 text-sm">You've reached the end</span>
        </div>
    </div>
</div>

<!-- Delete Confirmation Modal -->
<div id="delete-modal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
    <div class="bg-white rounded-lg shadow-xl w-full max-w-sm mx-4 p-6">
        <h3 class="text-lg font-semibold mb-4">Delete Post?</h3>
        <p class="text-gray-600 mb-6">This will permanently delete this post and all its comments.</p>
        <div class="flex justify-end gap-3">
            <button onclick="hideDeleteModal()" class="px-4 py-2 border border-gray-300 text-gray-700 rounded-md hover:bg-gray-50">
                Cancel
            </button>
            <button onclick="confirmDelete()" class="px-4 py-2 bg-red-600 text-white rounded-md hover:opacity-90">
                Delete
            </button>
        </div>
    </div>
</div>

<script>
    let currentFilter = 'all';
    let isLoading = false;
    let hasMore = true;
    let lastPostId = null;
    let currentUserId = null;
    let deletePostId = null; // For delete confirmation
    let pendingMedia = []; // Files selected for upload
    let expandedPosts = new Set(); // Track which posts have comments expanded
    let loadedComments = {}; // Cache loaded comments by post ID
    let replyingTo = {}; // Track which comment we're replying to: { rootPostId: commentId }
    const COMMENT_TRUNCATE_LENGTH = 280; // Characters before truncating

    const composerPlaceholders = [
        "What's on your mind?",
        "Share something!",
        "What are you working on?",
        "Got something to share?",
        "What's new with you?",
        "Share an update...",
        "What have you learned lately?",
        "Any wins to celebrate?",
        "What's inspiring you today?",
    ];

    function getRandomPlaceholder() {
        return composerPlaceholders[Math.floor(Math.random() * composerPlaceholders.length)];
    }

    function isTokenValid(token) {
        if (!token) return false;
        try {
            const base64Url = token.split('.')[1];
            const base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/');
            const payload = JSON.parse(window.atob(base64));
            return payload && payload.exp * 1000 > Date.now();
        } catch (e) {
            return false;
        }
    }

    async function init() {
        const token = localStorage.getItem('token');
        const isLoggedIn = isTokenValid(token);

        if (isLoggedIn) {
            document.getElementById('composer').classList.remove('hidden');
            document.getElementById('feed-tabs').classList.remove('hidden');
            document.getElementById('feed-container').classList.remove('hidden');

            // Set random placeholder
            const placeholder = getRandomPlaceholder();
            document.querySelector('#composer-collapsed input').placeholder = placeholder;
            document.getElementById('post-content').placeholder = placeholder;

            // Get current user ID and avatar
            try {
                const meResponse = await fetch('/api/me', {
                    headers: { 'Authorization': `Bearer ${token}` }
                });
                if (meResponse.ok) {
                    const me = await meResponse.json();
                    currentUserId = me.id;
                    // Set composer avatars
                    if (me.avatar_url) {
                        document.getElementById('composer-avatar-collapsed').src = me.avatar_url;
                        document.getElementById('composer-avatar-expanded').src = me.avatar_url;
                    }
                }
            } catch (e) {
                console.error('Failed to get user:', e);
            }

            await loadPosts();
            setupInfiniteScroll();
        } else {
            // Show public posts for guests
            document.getElementById('feed-container').classList.remove('hidden');
            document.getElementById('feed-tabs').classList.add('hidden');
            await loadPosts();
            setupInfiniteScroll();
        }
    }

    function switchFilter(filter) {
        currentFilter = filter;
        lastPostId = null;
        hasMore = true;

        // Update tab styles
        ['all', 'mine'].forEach(f => {
            const tab = document.getElementById(`tab-${f}`);
            if (f === filter) {
                tab.classList.add('border-brand-blue', 'text-brand-blue');
                tab.classList.remove('border-transparent', 'text-gray-500');
            } else {
                tab.classList.remove('border-brand-blue', 'text-brand-blue');
                tab.classList.add('border-transparent', 'text-gray-500');
            }
        });

        document.getElementById('posts-list').innerHTML = '';
        loadPosts();
    }

    async function loadPosts(append = false) {
        if (isLoading) return;
        isLoading = true;

        const token = localStorage.getItem('token');
        const loading = document.getElementById('loading-more');
        const noPosts = document.getElementById('no-posts');
        const endOfFeed = document.getElementById('end-of-feed');

        loading.classList.remove('hidden');
        noPosts.classList.add('hidden');
        endOfFeed.classList.add('hidden');

        try {
            let url = `/api/posts?filter=${currentFilter}&limit=20`;
            if (lastPostId && append) {
                url += `&before_id=${lastPostId}`;
            }

            const headers = token ? { 'Authorization': `Bearer ${token}` } : {};
            const response = await fetch(url, { headers });

            if (!response.ok) {
                throw new Error('Failed to load posts');
            }

            const data = await response.json();
            hasMore = data.has_more;

            const postsList = document.getElementById('posts-list');

            if (data.posts.length === 0 && !append) {
                noPosts.classList.remove('hidden');
            } else {
                const postsHtml = data.posts.map(post => renderPost(post)).join('');
                if (append) {
                    postsList.insertAdjacentHTML('beforeend', postsHtml);
                } else {
                    postsList.innerHTML = postsHtml;
                }

                if (data.posts.length > 0) {
                    lastPostId = data.posts[data.posts.length - 1].id;
                }

                if (!hasMore) {
                    endOfFeed.classList.remove('hidden');
                }
            }
        } catch (e) {
            console.error('Failed to load posts:', e);
        } finally {
            loading.classList.add('hidden');
            isLoading = false;
        }
    }

    function renderPost(post) {
        const authorUrl = `/u/${post.author.handle}`;
        const avatarUrl = post.author.avatar_url || '/static/default-avatar.svg';
        const timeStr = formatTime(post.created_at);

        const upvoteActive = post.user_vote === 1 ? 'text-green-600 font-semibold' : 'text-gray-500';
        const downvoteActive = post.user_vote === -1 ? 'text-red-600 font-semibold' : 'text-gray-500';

        const token = localStorage.getItem('token');
        const canVote = token && !post.is_mine;
        const voteButtonClass = canVote ? 'hover:opacity-70 cursor-pointer' : 'cursor-default';

        const visibilityIcon = post.visibility === 'public'
            ? `<svg class="w-4 h-4 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24" title="Public">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3.055 11H5a2 2 0 012 2v1a2 2 0 002 2 2 2 0 012 2v2.945M8 3.935V5.5A2.5 2.5 0 0010.5 8h.5a2 2 0 012 2 2 2 0 104 0 2 2 0 012-2h1.064M15 20.488V18a2 2 0 012-2h3.064M21 12a9 9 0 11-18 0 9 9 0 0118 0z"/>
               </svg>`
            : `<svg class="w-4 h-4 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24" title="Connections only">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4.354a4 4 0 110 5.292M15 21H3v-1a6 6 0 0112 0v1zm0 0h6v-1a6 6 0 00-9-5.197M13 7a4 4 0 11-8 0 4 4 0 018 0z"/>
               </svg>`;

        // Three dots menu for posts
        const postMenuItems = [];
        postMenuItems.push(`<button onclick="sharePost(${post.id}, '${post.author.handle}'); closePostMenu(${post.id})" class="w-full text-left px-4 py-2 text-gray-700 hover:bg-gray-100">Share</button>`);
        if (token && !post.is_mine) {
            postMenuItems.push(`<button onclick="reportAbuse(${post.id}); closePostMenu(${post.id})" class="w-full text-left px-4 py-2 text-gray-700 hover:bg-gray-100">Report Abuse</button>`);
        }
        if (post.is_mine) {
            postMenuItems.push(`<button onclick="showDeleteModal(${post.id}); closePostMenu(${post.id})" class="w-full text-left px-4 py-2 text-red-600 hover:bg-gray-100">Delete</button>`);
        }

        const postMenu = `
            <div class="relative ml-auto">
                <button onclick="togglePostMenu(${post.id}, event)" class="text-gray-400 hover:text-gray-600 p-1">
                    <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 20 20">
                        <path d="M10 6a2 2 0 110-4 2 2 0 010 4zM10 12a2 2 0 110-4 2 2 0 010 4zM10 18a2 2 0 110-4 2 2 0 010 4z"/>
                    </svg>
                </button>
                <div id="post-menu-${post.id}" class="hidden absolute right-0 top-full mt-1 w-36 bg-white rounded-lg shadow-lg border border-gray-200 py-1 z-50">
                    ${postMenuItems.join('')}
                </div>
            </div>
        `;

        return `
            <div class="bg-white sm:rounded-lg shadow" data-post-id="${post.id}">
                <div class="p-4">
                    <div class="flex items-start gap-3">
                        <a href="${authorUrl}">
                            <img src="${avatarUrl}" alt="" class="w-10 h-10 rounded-full object-cover bg-gray-200">
                        </a>
                        <div class="flex-1 min-w-0">
                            <div class="flex items-center gap-2 flex-wrap">
                                <a href="${authorUrl}" class="font-medium text-base text-gray-900 hover:underline">${escapeHtml(post.author.name || post.author.handle)}</a>
                                <span class="text-gray-400">@${post.author.handle}</span>
                                ${visibilityIcon}
                                <span class="text-gray-400 text-sm">${timeStr}</span>
                                ${postMenu}
                            </div>
                            <p class="text-gray-800 mt-2 whitespace-pre-wrap break-words">${formatContent(post.content)}</p>
                        </div>
                    </div>
                    ${renderPostMedia(post.media)}
                    <div class="flex items-center gap-4 mt-3 text-sm">
                        <div class="flex items-center gap-1 ${voteButtonClass}" ${canVote ? `onclick="vote(${post.id}, 1, event)"` : ''}>
                            <span class="${upvoteActive}">&#128077;</span>
                            <span id="upvotes-${post.id}" class="${upvoteActive}">${post.upvote_count}</span>
                        </div>
                        <div class="flex items-center gap-1 ${voteButtonClass}" ${canVote ? `onclick="vote(${post.id}, -1, event)"` : ''}>
                            <span class="${downvoteActive}">&#128078;</span>
                            <span id="downvotes-${post.id}" class="${downvoteActive}">${post.downvote_count}</span>
                        </div>
                        <button onclick="toggleComments(${post.id})" class="flex items-center gap-1 text-gray-500 hover:text-brand-blue" id="comment-btn-${post.id}">
                            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 12h.01M12 12h.01M16 12h.01M21 12c0 4.418-4.03 8-9 8a9.863 9.863 0 01-4.255-.949L3 20l1.395-3.72C3.512 15.042 3 13.574 3 12c0-4.418 4.03-8 9-8s9 3.582 9 8z"/>
                            </svg>
                            <span id="comment-count-${post.id}">${post.comment_count}</span>
                        </button>
                    </div>
                </div>
                <div id="comments-section-${post.id}" class="hidden border-t border-gray-100"></div>
            </div>
        `;
    }

    function formatContent(content) {
        // Escape HTML first
        let escaped = escapeHtml(content);
        // Convert @mentions to links
        escaped = escaped.replace(/@([a-z0-9_]{3,30})\b/g, '<a href="/u/$1" class="text-brand-blue hover:underline" onclick="event.stopPropagation()">@$1</a>');
        return escaped;
    }

    function formatTime(isoString) {
        if (!isoString) return '';
        const date = new Date(isoString);
        const now = new Date();
        const diffMs = now - date;
        const diffMins = Math.floor(diffMs / 60000);
        const diffHours = Math.floor(diffMs / 3600000);
        const diffDays = Math.floor(diffMs / 86400000);

        if (diffMins < 1) return 'now';
        if (diffMins < 60) return `${diffMins}m`;
        if (diffHours < 24) return `${diffHours}h`;
        if (diffDays < 7) return `${diffDays}d`;
        return date.toLocaleDateString([], { month: 'short', day: 'numeric' });
    }

    function escapeHtml(text) {
        if (!text) return '';
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }

    function renderPostMedia(media) {
        if (!media || media.length === 0) return '';

        const m = media[0];
        if (m.type === 'video') {
            return `<div class="mt-3 -mx-4"><video src="${m.url}" controls controlsList="nodownload noplaybackrate" disablePictureInPicture class="w-full" preload="metadata"></video></div>`;
        }
        return `<div class="mt-3 -mx-4"><img src="${m.url}" alt="" class="w-full cursor-pointer" onclick="openImageModal('${m.url}', event)"></div>`;
    }

    function openImageModal(url, event) {
        event.stopPropagation();
        // Create a simple fullscreen image viewer
        const overlay = document.createElement('div');
        overlay.id = 'image-modal';
        overlay.className = 'fixed inset-0 bg-black bg-opacity-90 flex items-center justify-center z-[100] cursor-pointer';
        overlay.onclick = () => overlay.remove();
        overlay.innerHTML = `
            <img src="${url}" class="max-w-full max-h-full object-contain">
            <button class="absolute top-4 right-4 text-white text-3xl hover:text-gray-300">&times;</button>
        `;
        document.body.appendChild(overlay);
    }

    function setupInfiniteScroll() {
        window.addEventListener('scroll', () => {
            if (isLoading || !hasMore) return;

            const scrollY = window.scrollY;
            const windowHeight = window.innerHeight;
            const docHeight = document.documentElement.scrollHeight;

            if (scrollY + windowHeight >= docHeight - 200) {
                loadPosts(true);
            }
        });
    }

    // Composer expand/collapse
    function expandComposer() {
        document.getElementById('composer-collapsed').classList.add('hidden');
        document.getElementById('composer-expanded').classList.remove('hidden');
        document.getElementById('post-content').focus();
    }

    function collapseComposer() {
        const content = document.getElementById('post-content').value.trim();
        if (content) return; // Don't collapse if there's content
        document.getElementById('composer-expanded').classList.add('hidden');
        document.getElementById('composer-collapsed').classList.remove('hidden');
    }

    function cancelComposer() {
        document.getElementById('post-content').value = '';
        document.getElementById('post-chars').textContent = '0/2000';
        clearPendingMedia();
        document.getElementById('composer-expanded').classList.add('hidden');
        document.getElementById('composer-collapsed').classList.remove('hidden');
    }

    // Media handling
    const ALLOWED_IMAGE_TYPES = ['image/jpeg', 'image/png', 'image/webp'];
    const ALLOWED_VIDEO_TYPES = ['video/mp4', 'video/webm', 'video/quicktime'];
    const MAX_IMAGE_SIZE = 5 * 1024 * 1024; // 5MB
    const MAX_VIDEO_SIZE = 100 * 1024 * 1024; // 100MB

    function handleMediaSelect(event) {
        const files = Array.from(event.target.files);

        // Only allow 1 media per post
        if (pendingMedia.length >= 1) {
            alert('Maximum 1 media per post');
            event.target.value = '';
            return;
        }

        const file = files[0];
        if (!file) return;

        const isImage = ALLOWED_IMAGE_TYPES.includes(file.type);
        const isVideo = ALLOWED_VIDEO_TYPES.includes(file.type);

        if (!isImage && !isVideo) {
            alert('Only JPEG, PNG, WebP images or MP4, WebM, MOV videos allowed');
            event.target.value = '';
            return;
        }

        const maxSize = isVideo ? MAX_VIDEO_SIZE : MAX_IMAGE_SIZE;
        if (file.size > maxSize) {
            alert(`File too large (max ${isVideo ? '100MB' : '5MB'})`);
            event.target.value = '';
            return;
        }

        pendingMedia = [file];

        // Clear input for re-selection
        event.target.value = '';
        renderMediaPreviews();
    }

    function renderMediaPreviews() {
        const container = document.getElementById('media-preview');
        if (pendingMedia.length === 0) {
            container.classList.add('hidden');
            container.innerHTML = '';
            updatePostButtonState();
            return;
        }

        container.classList.remove('hidden');
        container.innerHTML = pendingMedia.map((file, index) => {
            const url = URL.createObjectURL(file);
            const isVideo = file.type.startsWith('video/');
            const mediaEl = isVideo
                ? `<video src="${url}" class="w-20 h-20 object-cover rounded-lg"></video>`
                : `<img src="${url}" alt="" class="w-20 h-20 object-cover rounded-lg">`;
            return `
                <div class="relative">
                    ${mediaEl}
                    ${isVideo ? '<div class="absolute inset-0 flex items-center justify-center pointer-events-none"><span class="text-white text-2xl bg-black bg-opacity-50 rounded-full w-8 h-8 flex items-center justify-center">â–¶</span></div>' : ''}
                    <button type="button" onclick="removePendingMedia(${index})" class="absolute -top-2 -right-2 w-5 h-5 bg-gray-800 text-white rounded-full flex items-center justify-center text-xs hover:bg-red-600">
                        &times;
                    </button>
                </div>
            `;
        }).join('');
        updatePostButtonState();
    }

    function removePendingMedia(index) {
        pendingMedia.splice(index, 1);
        renderMediaPreviews();
    }

    function clearPendingMedia() {
        pendingMedia = [];
        document.getElementById('media-preview').classList.add('hidden');
        document.getElementById('media-preview').innerHTML = '';
        updatePostButtonState();
    }

    async function uploadMediaForPost(postId, token) {
        for (let i = 0; i < pendingMedia.length; i++) {
            const file = pendingMedia[i];
            try {
                // Step 1: Get presigned URL from server
                const urlRes = await fetch(`/api/posts/${postId}/media/upload-url`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${token}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ content_type: file.type, index: i })
                });
                if (!urlRes.ok) throw new Error('Failed to get upload URL');
                const { upload_url, media_path } = await urlRes.json();

                // Step 2: Upload directly to R2
                const uploadRes = await fetch(upload_url, {
                    method: 'PUT',
                    headers: { 'Content-Type': file.type },
                    body: file
                });
                if (!uploadRes.ok) throw new Error('Failed to upload to R2');

                // Step 3: Confirm upload with server
                await fetch(`/api/posts/${postId}/media/confirm`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${token}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ media_path, content_type: file.type })
                });
            } catch (e) {
                console.error('Failed to upload media:', e);
            }
        }
    }

    // Collapse when clicking outside composer
    document.addEventListener('click', (e) => {
        const composer = document.getElementById('composer');
        const expanded = document.getElementById('composer-expanded');
        if (!composer.contains(e.target) && !expanded.classList.contains('hidden')) {
            collapseComposer();
        }
    });

    // Post form
    function updatePostButtonState() {
        const content = document.getElementById('post-content').value.trim();
        document.getElementById('post-submit').disabled = content.length === 0;
    }

    document.getElementById('post-content').addEventListener('input', (e) => {
        document.getElementById('post-chars').textContent = `${e.target.value.length}/2000`;
        updatePostButtonState();
    });

    document.getElementById('post-form').addEventListener('submit', async (e) => {
        e.preventDefault();
        const content = document.getElementById('post-content').value.trim();
        const visibility = document.getElementById('post-visibility').value;

        if (!content && pendingMedia.length === 0) return;

        const token = localStorage.getItem('token');
        if (!token) {
            window.location.href = '/login';
            return;
        }

        try {
            const response = await fetch('/api/posts', {
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${token}`,
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ content: content || ' ', visibility })
            });

            if (response.ok) {
                const result = await response.json();

                // Upload any pending media
                if (pendingMedia.length > 0) {
                    await uploadMediaForPost(result.id, token);
                }

                document.getElementById('post-content').value = '';
                document.getElementById('post-chars').textContent = '0/2000';
                clearPendingMedia();
                collapseComposer();
                // Reload feed to show new post
                lastPostId = null;
                hasMore = true;
                await loadPosts();
            } else {
                const error = await response.json();
                const message = typeof error.detail === 'string' ? error.detail : 'Failed to create post';
                alert(message);
            }
        } catch (e) {
            console.error('Failed to create post:', e);
            alert('Failed to create post');
        }
    });

    // Voting
    async function vote(postId, value, event) {
        event.stopPropagation();

        const token = localStorage.getItem('token');
        if (!token) {
            window.location.href = '/login';
            return;
        }

        try {
            // Check if clicking same vote to remove it
            const postEl = document.querySelector(`[data-post-id="${postId}"]`);
            const upvotesEl = document.getElementById(`upvotes-${postId}`);
            const downvotesEl = document.getElementById(`downvotes-${postId}`);

            // Determine if we should remove or set vote
            const currentUpClass = upvotesEl.className;
            const currentDownClass = downvotesEl.className;
            const hasUpvote = currentUpClass.includes('text-green-600');
            const hasDownvote = currentDownClass.includes('text-red-600');

            let response;
            if ((value === 1 && hasUpvote) || (value === -1 && hasDownvote)) {
                // Remove vote
                response = await fetch(`/api/posts/${postId}/vote`, {
                    method: 'DELETE',
                    headers: { 'Authorization': `Bearer ${token}` }
                });
            } else {
                // Set vote
                response = await fetch(`/api/posts/${postId}/vote`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${token}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ value })
                });
            }

            if (response.ok) {
                const data = await response.json();
                updateVoteDisplay(postId, data);
            }
        } catch (e) {
            console.error('Failed to vote:', e);
        }
    }

    function updateVoteDisplay(postId, data) {
        const upvotesEl = document.getElementById(`upvotes-${postId}`);
        const downvotesEl = document.getElementById(`downvotes-${postId}`);

        if (upvotesEl) {
            upvotesEl.textContent = data.upvote_count;
            upvotesEl.className = data.user_vote === 1 ? 'text-green-600 font-semibold' : 'text-gray-500';
            upvotesEl.previousElementSibling.className = data.user_vote === 1 ? 'text-green-600 font-semibold' : 'text-gray-500';
        }
        if (downvotesEl) {
            downvotesEl.textContent = data.downvote_count;
            downvotesEl.className = data.user_vote === -1 ? 'text-red-600 font-semibold' : 'text-gray-500';
            downvotesEl.previousElementSibling.className = data.user_vote === -1 ? 'text-red-600 font-semibold' : 'text-gray-500';
        }
    }

    // Inline Comments System
    async function toggleComments(postId) {
        const section = document.getElementById(`comments-section-${postId}`);

        if (expandedPosts.has(postId)) {
            // Collapse
            section.classList.add('hidden');
            expandedPosts.delete(postId);
        } else {
            // Expand
            section.classList.remove('hidden');
            expandedPosts.add(postId);

            // Load comments if not cached
            if (!loadedComments[postId]) {
                section.innerHTML = '<div class="p-4 text-center text-gray-500">Loading...</div>';
                await loadComments(postId);
            } else {
                renderCommentsSection(postId, loadedComments[postId]);
            }
        }
    }

    async function loadComments(postId) {
        const token = localStorage.getItem('token');
        const headers = token ? { 'Authorization': `Bearer ${token}` } : {};

        try {
            const response = await fetch(`/api/posts/${postId}`, { headers });
            if (!response.ok) {
                console.error('Failed to load comments');
                return;
            }

            const data = await response.json();
            loadedComments[postId] = data.comments;
            renderCommentsSection(postId, data.comments);
        } catch (e) {
            console.error('Failed to load comments:', e);
        }
    }

    function renderCommentsSection(postId, comments) {
        const section = document.getElementById(`comments-section-${postId}`);
        const token = localStorage.getItem('token');

        let html = '<div class="divide-y divide-gray-100">';

        if (comments.length === 0) {
            html += '<div class="p-4 text-center text-gray-500 text-sm">No comments yet</div>';
        } else {
            comments.forEach(comment => {
                html += renderComment(comment, postId, comments);
            });
        }

        html += '</div>';

        // Reply form
        if (token) {
            html += `
                <div class="p-3 border-t border-gray-100">
                    <div id="reply-indicator-${postId}" class="hidden text-xs text-brand-blue mb-2 flex items-center"></div>
                    <form onsubmit="submitReply(event, ${postId})" class="flex gap-2">
                        <input type="text" id="reply-input-${postId}" placeholder="Write a comment..." maxlength="2000"
                            class="flex-1 px-3 py-2 border border-gray-300 rounded-full text-sm focus:outline-none focus:ring-2 focus:ring-brand-blue">
                        <button type="submit" class="px-4 py-2 bg-brand-blue text-white rounded-full hover:opacity-90 text-sm">
                            Reply
                        </button>
                    </form>
                </div>
            `;
        }

        section.innerHTML = html;
    }

    function renderComment(comment, rootPostId, allComments) {
        const authorUrl = `/u/${comment.author.handle}`;
        const avatarUrl = comment.author.avatar_url || '/static/default-avatar.svg';
        const timeStr = formatTime(comment.created_at);

        const upvoteActive = comment.user_vote === 1 ? 'text-green-600 font-semibold' : 'text-gray-500';
        const downvoteActive = comment.user_vote === -1 ? 'text-red-600 font-semibold' : 'text-gray-500';

        const token = localStorage.getItem('token');
        const canVote = token && !comment.is_mine;
        const voteButtonClass = canVote ? 'hover:opacity-70 cursor-pointer' : 'cursor-default';

        // Three dots menu with Delete (if own) and Report Abuse
        const menuItems = [];
        if (comment.is_mine) {
            menuItems.push(`<button onclick="showDeleteModal(${comment.id}, ${rootPostId}); closeCommentMenu(${comment.id})" class="w-full text-left px-4 py-2 text-gray-700 hover:bg-gray-100">Delete</button>`);
        }
        if (token && !comment.is_mine) {
            menuItems.push(`<button onclick="reportAbuse(${comment.id}); closeCommentMenu(${comment.id})" class="w-full text-left px-4 py-2 text-gray-700 hover:bg-gray-100">Report Abuse</button>`);
        }

        const commentMenu = menuItems.length > 0 ? `
            <div class="relative ml-auto">
                <button onclick="toggleCommentMenu(${comment.id}, event)" class="text-gray-400 hover:text-gray-600 p-1">
                    <svg class="w-4 h-4" fill="currentColor" viewBox="0 0 20 20">
                        <path d="M10 6a2 2 0 110-4 2 2 0 010 4zM10 12a2 2 0 110-4 2 2 0 010 4zM10 18a2 2 0 110-4 2 2 0 010 4z"/>
                    </svg>
                </button>
                <div id="comment-menu-${comment.id}" class="hidden absolute right-0 top-full mt-1 w-36 bg-white rounded-lg shadow-lg border border-gray-200 py-1 z-50">
                    ${menuItems.join('')}
                </div>
            </div>
        ` : '';

        // Check if this is a reply to another comment (not the root post)
        let replyToButton = '';
        if (comment.reply_to_id && comment.reply_to_id !== rootPostId) {
            // Find the parent comment
            const parentComment = allComments.find(c => c.id === comment.reply_to_id);
            if (parentComment) {
                replyToButton = `<button onclick="scrollToComment(${comment.reply_to_id})" class="text-brand-blue hover:underline flex items-center justify-center w-6 h-6" title="Jump to parent comment">
                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20 20h-8v-16M12 4l-4 4m4-4l4 4"/>
                    </svg>
                </button>`;
            }
        }

        // Truncate long comments
        const content = comment.content || '';
        const isTruncated = content.length > COMMENT_TRUNCATE_LENGTH;
        const displayContent = isTruncated
            ? content.substring(0, COMMENT_TRUNCATE_LENGTH) + '...'
            : content;
        const showMoreButton = isTruncated
            ? `<button onclick="expandComment(${comment.id})" class="text-brand-blue hover:underline text-xs" id="expand-btn-${comment.id}">show more</button>`
            : '';

        return `
            <div class="p-3 hover:bg-gray-50" id="comment-${comment.id}" data-post-id="${comment.id}">
                <div class="flex items-start gap-2">
                    ${replyToButton ? `<div class="flex-shrink-0 pt-1">${replyToButton}</div>` : ''}
                    <a href="${authorUrl}" class="flex-shrink-0">
                        <img src="${avatarUrl}" alt="" class="w-8 h-8 rounded-full object-cover bg-gray-200">
                    </a>
                    <div class="flex-1 min-w-0">
                        <div class="flex items-center gap-2 flex-wrap text-sm">
                            <a href="${authorUrl}" class="font-medium text-gray-900 hover:underline">${escapeHtml(comment.author.name || comment.author.handle)}</a>
                            <span class="text-gray-400 text-xs">${timeStr}</span>
                            ${commentMenu}
                        </div>
                        <p class="text-gray-800 mt-1 whitespace-pre-wrap break-words text-sm" id="content-${comment.id}" data-full="${escapeHtml(content)}">${formatContent(displayContent)}</p>
                        ${showMoreButton}
                        <div class="flex items-center gap-3 mt-2 text-xs">
                            <div class="flex items-center gap-1 ${voteButtonClass}" ${canVote ? `onclick="vote(${comment.id}, 1, event)"` : ''}>
                                <span class="${upvoteActive}">&#128077;</span>
                                <span id="upvotes-${comment.id}" class="${upvoteActive}">${comment.upvote_count}</span>
                            </div>
                            <div class="flex items-center gap-1 ${voteButtonClass}" ${canVote ? `onclick="vote(${comment.id}, -1, event)"` : ''}>
                                <span class="${downvoteActive}">&#128078;</span>
                                <span id="downvotes-${comment.id}" class="${downvoteActive}">${comment.downvote_count}</span>
                            </div>
                            ${token ? `<button onclick="replyToComment(${rootPostId}, ${comment.id})" class="text-gray-500 hover:text-brand-blue">Reply</button>` : ''}
                        </div>
                    </div>
                </div>
            </div>
        `;
    }

    function expandComment(commentId) {
        const contentEl = document.getElementById(`content-${commentId}`);
        const expandBtn = document.getElementById(`expand-btn-${commentId}`);
        if (contentEl && expandBtn) {
            const fullContent = contentEl.dataset.full;
            contentEl.innerHTML = formatContent(fullContent);
            expandBtn.remove();
        }
    }

    function scrollToComment(commentId) {
        const commentEl = document.getElementById(`comment-${commentId}`);
        if (commentEl) {
            commentEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
            // Highlight briefly
            commentEl.classList.add('bg-yellow-50');
            setTimeout(() => {
                commentEl.classList.remove('bg-yellow-50');
            }, 1500);
        }
    }

    async function submitReply(event, rootPostId) {
        event.preventDefault();

        const input = document.getElementById(`reply-input-${rootPostId}`);
        const content = input.value.trim();
        if (!content) return;

        const token = localStorage.getItem('token');
        if (!token) {
            window.location.href = '/login';
            return;
        }

        // Determine what we're replying to (a comment or the root post)
        const targetId = replyingTo[rootPostId] || rootPostId;

        try {
            const response = await fetch(`/api/posts/${targetId}/reply`, {
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${token}`,
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ content })
            });

            if (response.ok) {
                input.value = '';
                // Clear reply target
                delete replyingTo[rootPostId];
                clearReplyIndicator(rootPostId);
                // Clear cache and reload comments
                delete loadedComments[rootPostId];
                await loadComments(rootPostId);
                // Update comment count
                const countEl = document.getElementById(`comment-count-${rootPostId}`);
                if (countEl) {
                    countEl.textContent = parseInt(countEl.textContent) + 1;
                }
            } else {
                const error = await response.json();
                alert(error.detail || 'Failed to post comment');
            }
        } catch (e) {
            console.error('Failed to post comment:', e);
            alert('Failed to post comment');
        }
    }

    function replyToComment(rootPostId, commentId) {
        replyingTo[rootPostId] = commentId;
        const input = document.getElementById(`reply-input-${rootPostId}`);
        if (input) {
            input.focus();
            // Show reply indicator
            showReplyIndicator(rootPostId);
        }
    }

    function showReplyIndicator(rootPostId) {
        const indicator = document.getElementById(`reply-indicator-${rootPostId}`);
        if (indicator) {
            indicator.innerHTML = `Replying <button onclick="cancelReplyTo(${rootPostId})" class="text-gray-400 hover:text-gray-600 ml-1">&times;</button>`;
            indicator.classList.remove('hidden');
        }
    }

    function clearReplyIndicator(rootPostId) {
        const indicator = document.getElementById(`reply-indicator-${rootPostId}`);
        if (indicator) {
            indicator.classList.add('hidden');
            indicator.innerHTML = '';
        }
    }

    function cancelReplyTo(rootPostId) {
        delete replyingTo[rootPostId];
        clearReplyIndicator(rootPostId);
        const input = document.getElementById(`reply-input-${rootPostId}`);
        if (input) {
            input.value = '';
        }
    }

    // Delete modal
    let deleteRootPostId = null; // Root post ID for comment deletion refresh

    function showDeleteModal(postId, rootPostId = null) {
        deletePostId = postId;
        deleteRootPostId = rootPostId;
        document.getElementById('delete-modal').classList.remove('hidden');
    }

    function hideDeleteModal() {
        deletePostId = null;
        deleteRootPostId = null;
        document.getElementById('delete-modal').classList.add('hidden');
    }

    async function confirmDelete() {
        if (!deletePostId) return;

        const token = localStorage.getItem('token');
        if (!token) return;

        try {
            const response = await fetch(`/api/posts/${deletePostId}`, {
                method: 'DELETE',
                headers: { 'Authorization': `Bearer ${token}` }
            });

            if (response.ok) {
                const wasComment = deleteRootPostId !== null;
                const rootId = deleteRootPostId;
                hideDeleteModal();

                if (wasComment && rootId) {
                    // Refresh comments for the root post
                    delete loadedComments[rootId];
                    await loadComments(rootId);
                    // Update comment count
                    const countEl = document.getElementById(`comment-count-${rootId}`);
                    if (countEl) {
                        countEl.textContent = Math.max(0, parseInt(countEl.textContent) - 1);
                    }
                } else {
                    // Refresh feed for post deletion
                    lastPostId = null;
                    hasMore = true;
                    await loadPosts();
                }
            } else {
                const error = await response.json();
                alert(error.detail || 'Failed to delete');
            }
        } catch (e) {
            console.error('Failed to delete:', e);
            alert('Failed to delete');
        }
    }

    // Comment menu functions
    function toggleCommentMenu(commentId, event) {
        event.stopPropagation();
        // Close all other menus first
        document.querySelectorAll('[id^="comment-menu-"]').forEach(menu => {
            if (menu.id !== `comment-menu-${commentId}`) {
                menu.classList.add('hidden');
            }
        });
        const menu = document.getElementById(`comment-menu-${commentId}`);
        if (menu) {
            menu.classList.toggle('hidden');
        }
    }

    function closeCommentMenu(commentId) {
        const menu = document.getElementById(`comment-menu-${commentId}`);
        if (menu) {
            menu.classList.add('hidden');
        }
    }

    // Post menu functions
    function togglePostMenu(postId, event) {
        event.stopPropagation();
        // Close all other menus first
        document.querySelectorAll('[id^="post-menu-"], [id^="comment-menu-"]').forEach(menu => {
            if (menu.id !== `post-menu-${postId}`) {
                menu.classList.add('hidden');
            }
        });
        const menu = document.getElementById(`post-menu-${postId}`);
        if (menu) {
            menu.classList.toggle('hidden');
        }
    }

    function closePostMenu(postId) {
        const menu = document.getElementById(`post-menu-${postId}`);
        if (menu) {
            menu.classList.add('hidden');
        }
    }

    function sharePost(postId, authorHandle) {
        const url = `${window.location.origin}/u/${authorHandle}/post/${postId}`;
        if (navigator.share) {
            navigator.share({
                title: 'Post on JustPros',
                url: url
            }).catch(() => {
                // User cancelled or share failed, fall back to clipboard
                copyToClipboard(url);
            });
        } else {
            copyToClipboard(url);
        }
    }

    function copyToClipboard(text) {
        navigator.clipboard.writeText(text).then(() => {
            alert('Link copied to clipboard!');
        }).catch(() => {
            // Fallback for older browsers
            const textarea = document.createElement('textarea');
            textarea.value = text;
            document.body.appendChild(textarea);
            textarea.select();
            document.execCommand('copy');
            document.body.removeChild(textarea);
            alert('Link copied to clipboard!');
        });
    }

    // Close menus when clicking outside
    document.addEventListener('click', (e) => {
        if (!e.target.closest('[id^="comment-menu-"]') && !e.target.closest('[id^="post-menu-"]') && !e.target.closest('button')) {
            document.querySelectorAll('[id^="comment-menu-"], [id^="post-menu-"]').forEach(menu => {
                menu.classList.add('hidden');
            });
        }
    });

    async function reportAbuse(postId) {
        const token = localStorage.getItem('token');
        if (!token) {
            window.location.href = '/login';
            return;
        }

        if (!confirm('Report this content for abuse? Our team will review it.')) {
            return;
        }

        try {
            const response = await fetch(`/api/posts/${postId}/report`, {
                method: 'POST',
                headers: { 'Authorization': `Bearer ${token}` }
            });

            if (response.ok) {
                alert('Report submitted. Thank you for helping keep JustPros clean.');
            } else {
                const error = await response.json();
                alert(error.detail || 'Failed to submit report');
            }
        } catch (e) {
            console.error('Failed to report:', e);
            alert('Failed to submit report');
        }
    }

    // ESC key to close modals
    document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
            // Close all menus
            document.querySelectorAll('[id^="comment-menu-"], [id^="post-menu-"]').forEach(menu => {
                menu.classList.add('hidden');
            });
            const imageModal = document.getElementById('image-modal');
            if (imageModal) {
                imageModal.remove();
            } else if (!document.getElementById('delete-modal').classList.contains('hidden')) {
                hideDeleteModal();
            }
        }
    });

    init();
</script>
{% endblock %}
