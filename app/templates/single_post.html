{% extends "base.html" %}

{% block title %}{{ author_name or handle }} on JustPros{% endblock %}
{% block description %}{{ og_description or 'Post on JustPros' }}{% endblock %}
{% block og_title %}{{ author_name or handle }} on JustPros{% endblock %}
{% block og_description %}{{ og_description or 'Post on JustPros' }}{% endblock %}
{% if og_image %}{% block og_image %}{{ og_image }}{% endblock %}{% endif %}
{% block og_url %}/u/{{ handle }}/post/{{ post_id }}{% endblock %}
{% block twitter_title %}{{ author_name or handle }} on JustPros{% endblock %}
{% block twitter_description %}{{ og_description or 'Post on JustPros' }}{% endblock %}
{% if og_image %}{% block twitter_image %}{{ og_image }}{% endblock %}{% endif %}

{% block content %}
<div class="max-w-2xl mx-auto">
    <!-- Go to feed link -->
    <div class="mb-2 px-4 sm:px-0">
        <a href="/" class="text-brand-blue hover:underline text-sm flex items-center gap-1">
            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"/>
            </svg>
            Go to feed
        </a>
    </div>

    <!-- Post Container -->
    <div id="post-container">
        <div class="py-8 text-center text-gray-500">Loading...</div>
    </div>
</div>

<!-- Delete Confirmation Modal -->
<div id="delete-modal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
    <div class="bg-white rounded-lg shadow-xl w-full max-w-sm mx-4 p-6">
        <h3 class="text-lg font-semibold mb-4">Delete Post?</h3>
        <p class="text-gray-600 mb-6">This will permanently delete this post and all its comments.</p>
        <div class="flex justify-end gap-3">
            <button onclick="hideDeleteModal()" class="px-4 py-2 border border-gray-300 text-gray-700 rounded-md hover:bg-gray-50">
                Cancel
            </button>
            <button onclick="confirmDelete()" class="px-4 py-2 bg-red-600 text-white rounded-md hover:bg-red-700">
                Delete
            </button>
        </div>
    </div>
</div>

<script src="/static/js/posts.js"></script>
<script>
    const POST_ID = {{ post_id }};
    const HANDLE = '{{ handle }}';
    let loadedComments = {};
    let replyingTo = {};
    let deletePostId = null;
    let deleteRootPostId = null;
    const COMMENT_TRUNCATE_LENGTH = 280;

    // Uses shared functions from /static/js/posts.js:
    // - escapeHtml, formatTime, formatPostContent, renderPostMedia, openImageModal
    // - SCALE_COLORS, getScaleColor, renderScaleIcon, renderVotePicker
    // - togglePostMenu, closePostMenu, sharePost

    async function init() {
        await loadPost();
    }

    async function loadPost() {
        const token = localStorage.getItem('token');
        const headers = token ? { 'Authorization': `Bearer ${token}` } : {};

        try {
            const response = await fetch(`/api/posts/${POST_ID}`, { headers });

            if (response.status === 404) {
                document.getElementById('post-container').innerHTML = `
                    <div class="bg-white sm:rounded-lg shadow p-8 text-center">
                        <p class="text-gray-500">Post not found</p>
                        <a href="/" class="text-brand-blue hover:underline mt-2 inline-block">Go to feed</a>
                    </div>
                `;
                return;
            }

            if (!response.ok) {
                throw new Error('Failed to load post');
            }

            const data = await response.json();
            loadedComments[POST_ID] = data.comments;
            displayPost(data.post, data.comments);
        } catch (e) {
            console.error('Failed to load post:', e);
            document.getElementById('post-container').innerHTML = `
                <div class="bg-white sm:rounded-lg shadow p-8 text-center">
                    <p class="text-gray-500">Failed to load post</p>
                    <a href="/" class="text-brand-blue hover:underline mt-2 inline-block">Go to feed</a>
                </div>
            `;
        }
    }

    let currentUserVotes = {}; // Track user's votes per post

    function displayPost(post, comments) {
        const commentsHtml = renderCommentsSection(POST_ID, comments);
        // Use shared renderPost with commentsHtml option for single post view
        document.getElementById('post-container').innerHTML = renderPost(post, {
            currentUserVotes,
            commentsHtml
        });
    }

    function renderCommentsSection(postId, comments) {
        const token = localStorage.getItem('token');
        let html = '<div class="divide-y divide-gray-100">';

        if (comments.length === 0) {
            html += '<div class="p-4 text-center text-gray-500 text-sm">No comments yet</div>';
        } else {
            comments.forEach(comment => {
                html += renderComment(comment, postId, comments);
            });
        }

        html += '</div>';

        // Reply form
        if (token) {
            html += `
                <div class="p-3 border-t border-gray-100">
                    <div id="reply-indicator-${postId}" class="hidden text-xs text-brand-blue mb-2 flex items-center"></div>
                    <form onsubmit="submitReply(event, ${postId})" class="flex gap-2">
                        <input type="text" id="reply-input-${postId}" placeholder="Write a comment..." maxlength="2000"
                            class="flex-1 px-3 py-2 border border-gray-300 rounded-full text-sm focus:outline-none focus:ring-2 focus:ring-brand-blue">
                        <button type="submit" class="px-4 py-2 bg-brand-blue text-white rounded-full hover:opacity-90 text-sm">
                            Reply
                        </button>
                    </form>
                </div>
            `;
        }

        return html;
    }

    function renderComment(comment, rootPostId, allComments) {
        const authorUrl = `/u/${comment.author.handle}`;
        const avatarUrl = comment.author.avatar_url || '/static/default-avatar.svg';
        const timeStr = formatTime(comment.created_at);

        // Track user's vote for this comment
        if (comment.user_vote !== null) {
            currentUserVotes[comment.id] = comment.user_vote;
        }

        const token = localStorage.getItem('token');
        const canVote = token && !comment.is_mine;
        const voteButtonClass = canVote ? 'hover:opacity-80 cursor-pointer' : 'cursor-default';

        // Three dots menu with Delete (if own) and Report Abuse
        const menuItems = [];
        if (comment.is_mine) {
            menuItems.push(`<button onclick="showDeleteModal(${comment.id}, ${rootPostId}); closeCommentMenu(${comment.id})" class="w-full text-left px-4 py-2 text-gray-700 hover:bg-gray-100">Delete</button>`);
        }
        if (token && !comment.is_mine) {
            menuItems.push(`<button onclick="reportAbuse(${comment.id}); closeCommentMenu(${comment.id})" class="w-full text-left px-4 py-2 text-gray-700 hover:bg-gray-100">Report Abuse</button>`);
        }

        const commentMenu = menuItems.length > 0 ? `
            <div class="relative ml-auto">
                <button onclick="toggleCommentMenu(${comment.id}, event)" class="text-gray-400 hover:text-gray-600 p-1">
                    <svg class="w-4 h-4" fill="currentColor" viewBox="0 0 20 20">
                        <path d="M10 6a2 2 0 110-4 2 2 0 010 4zM10 12a2 2 0 110-4 2 2 0 010 4zM10 18a2 2 0 110-4 2 2 0 010 4z"/>
                    </svg>
                </button>
                <div id="comment-menu-${comment.id}" class="hidden absolute right-0 top-full mt-1 w-36 bg-white rounded-lg shadow-lg border border-gray-200 py-1 z-50">
                    ${menuItems.join('')}
                </div>
            </div>
        ` : '';

        // Check if this is a reply to another comment (not the root post)
        let replyToButton = '';
        if (comment.reply_to_id && comment.reply_to_id !== rootPostId) {
            const parentComment = allComments.find(c => c.id === comment.reply_to_id);
            if (parentComment) {
                replyToButton = `<button onclick="scrollToComment(${comment.reply_to_id})" class="text-brand-blue hover:underline flex items-center justify-center w-6 h-6" title="Jump to parent comment">
                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20 20h-8v-16M12 4l-4 4m4-4l4 4"/>
                    </svg>
                </button>`;
            }
        }

        // Truncate long comments
        const content = comment.content || '';
        const isTruncated = content.length > COMMENT_TRUNCATE_LENGTH;
        const displayContent = isTruncated ? content.substring(0, COMMENT_TRUNCATE_LENGTH) + '...' : content;
        const showMoreButton = isTruncated
            ? `<button onclick="expandComment(${comment.id})" class="text-brand-blue hover:underline text-xs" id="expand-btn-${comment.id}">show more</button>`
            : '';

        return `
            <div class="p-3 hover:bg-gray-50" id="comment-${comment.id}" data-post-id="${comment.id}">
                <div class="flex items-start gap-2">
                    ${replyToButton ? `<div class="flex-shrink-0 pt-1">${replyToButton}</div>` : ''}
                    <a href="${authorUrl}" class="flex-shrink-0">
                        <img src="${avatarUrl}" alt="" class="w-8 h-8 rounded-full object-cover bg-gray-200">
                    </a>
                    <div class="flex-1 min-w-0">
                        <div class="flex items-center gap-2 flex-wrap text-sm">
                            <a href="${authorUrl}" class="font-medium text-gray-900 hover:underline">${escapeHtml(comment.author.name || comment.author.handle)}</a>
                            <span class="text-gray-400 text-xs">${timeStr}</span>
                            ${commentMenu}
                        </div>
                        <p class="text-gray-800 mt-1 whitespace-pre-wrap break-words text-sm" id="content-${comment.id}" data-full="${escapeHtml(content)}">${formatPostContent(displayContent)}</p>
                        ${showMoreButton}
                        <div class="flex items-center gap-3 mt-2 text-xs">
                            <div class="relative" id="vote-container-${comment.id}">
                                <button class="flex items-center gap-1 ${voteButtonClass}" ${canVote ? `onclick="toggleVotePicker(${comment.id}, event)"` : ''}>
                                    <span id="scale-icon-${comment.id}" class="${comment.user_vote !== null ? 'ring-2 ring-brand-blue ring-offset-1 rounded-full' : ''}">${renderScaleIcon(comment.display_level || 0, 20)}</span>
                                    <span id="vote-count-${comment.id}" class="text-gray-500">${comment.vote_count}</span>
                                </button>
                                <div id="vote-picker-${comment.id}" class="hidden"></div>
                            </div>
                            ${token ? `<button onclick="replyToComment(${rootPostId}, ${comment.id})" class="text-gray-500 hover:text-brand-blue">Reply</button>` : ''}
                        </div>
                    </div>
                </div>
            </div>
        `;
    }

    function expandComment(commentId) {
        const contentEl = document.getElementById(`content-${commentId}`);
        const expandBtn = document.getElementById(`expand-btn-${commentId}`);
        if (contentEl && expandBtn) {
            const fullContent = contentEl.dataset.full;
            contentEl.innerHTML = formatPostContent(fullContent);
            expandBtn.remove();
        }
    }

    function scrollToComment(commentId) {
        const commentEl = document.getElementById(`comment-${commentId}`);
        if (commentEl) {
            commentEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
            commentEl.classList.add('bg-yellow-50');
            setTimeout(() => {
                commentEl.classList.remove('bg-yellow-50');
            }, 1500);
        }
    }

    // Scale Voting System
    function toggleVotePicker(postId, event) {
        event.stopPropagation();
        const picker = document.getElementById(`vote-picker-${postId}`);
        if (!picker) return;

        // Close any other open pickers
        document.querySelectorAll('[id^="vote-picker-"]').forEach(p => {
            if (p.id !== `vote-picker-${postId}`) {
                p.classList.add('hidden');
            }
        });

        if (picker.classList.contains('hidden')) {
            picker.innerHTML = renderVotePicker(postId, currentUserVotes[postId] ?? null);
            picker.classList.remove('hidden');

            const closeHandler = (e) => {
                if (!picker.contains(e.target) && !e.target.closest(`#vote-container-${postId}`)) {
                    picker.classList.add('hidden');
                    document.removeEventListener('click', closeHandler);
                }
            };
            setTimeout(() => document.addEventListener('click', closeHandler), 0);
        } else {
            picker.classList.add('hidden');
        }
    }

    async function submitVote(postId, value, event) {
        event.stopPropagation();
        const token = localStorage.getItem('token');
        if (!token) {
            window.location.href = '/login';
            return;
        }

        try {
            const response = await fetch(`/api/posts/${postId}/vote`, {
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${token}`,
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ value })
            });

            if (response.ok) {
                const data = await response.json();
                updateScaleDisplay(postId, data);
                document.getElementById(`vote-picker-${postId}`).classList.add('hidden');
            }
        } catch (e) {
            console.error('Failed to vote:', e);
        }
    }

    function updateScaleDisplay(postId, data) {
        currentUserVotes[postId] = data.user_vote;

        // Update scale icon and ring indicator
        const iconEl = document.getElementById(`scale-icon-${postId}`);
        if (iconEl) {
            iconEl.innerHTML = renderScaleIcon(data.display_level, 24);
            if (data.user_vote !== null) {
                iconEl.className = 'ring-2 ring-brand-blue ring-offset-1 rounded-full';
            } else {
                iconEl.className = '';
            }
        }

        // Update vote count (always show)
        const countEl = document.getElementById(`vote-count-${postId}`);
        if (countEl) {
            countEl.textContent = data.vote_count;
        }
    }

    // Comments
    async function loadComments(postId) {
        const token = localStorage.getItem('token');
        const headers = token ? { 'Authorization': `Bearer ${token}` } : {};

        try {
            const response = await fetch(`/api/posts/${postId}`, { headers });
            if (!response.ok) return;

            const data = await response.json();
            loadedComments[postId] = data.comments;
            const section = document.getElementById(`comments-section-${postId}`);
            if (section) {
                section.innerHTML = renderCommentsSection(postId, data.comments);
            }
        } catch (e) {
            console.error('Failed to load comments:', e);
        }
    }

    async function submitReply(event, rootPostId) {
        event.preventDefault();

        const input = document.getElementById(`reply-input-${rootPostId}`);
        const content = input.value.trim();
        if (!content) return;

        const token = localStorage.getItem('token');
        if (!token) {
            window.location.href = '/login';
            return;
        }

        const targetId = replyingTo[rootPostId] || rootPostId;

        try {
            const response = await fetch(`/api/posts/${targetId}/reply`, {
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${token}`,
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ content })
            });

            if (response.ok) {
                input.value = '';
                delete replyingTo[rootPostId];
                clearReplyIndicator(rootPostId);
                delete loadedComments[rootPostId];
                await loadComments(rootPostId);
                const countEl = document.getElementById(`comment-count-${rootPostId}`);
                if (countEl) {
                    countEl.textContent = parseInt(countEl.textContent) + 1;
                }
            } else {
                const error = await response.json();
                alert(error.detail || 'Failed to post comment');
            }
        } catch (e) {
            console.error('Failed to post comment:', e);
            alert('Failed to post comment');
        }
    }

    function replyToComment(rootPostId, commentId) {
        replyingTo[rootPostId] = commentId;
        const input = document.getElementById(`reply-input-${rootPostId}`);
        if (input) {
            input.focus();
            showReplyIndicator(rootPostId);
        }
    }

    function showReplyIndicator(rootPostId) {
        const indicator = document.getElementById(`reply-indicator-${rootPostId}`);
        if (indicator) {
            indicator.innerHTML = `Replying <button onclick="cancelReplyTo(${rootPostId})" class="text-gray-400 hover:text-gray-600 ml-1">&times;</button>`;
            indicator.classList.remove('hidden');
        }
    }

    function clearReplyIndicator(rootPostId) {
        const indicator = document.getElementById(`reply-indicator-${rootPostId}`);
        if (indicator) {
            indicator.classList.add('hidden');
            indicator.innerHTML = '';
        }
    }

    function cancelReplyTo(rootPostId) {
        delete replyingTo[rootPostId];
        clearReplyIndicator(rootPostId);
        const input = document.getElementById(`reply-input-${rootPostId}`);
        if (input) {
            input.value = '';
        }
    }

    // Delete modal
    function showDeleteModal(postId, rootPostId = null) {
        deletePostId = postId;
        deleteRootPostId = rootPostId;
        document.getElementById('delete-modal').classList.remove('hidden');
    }

    function hideDeleteModal() {
        deletePostId = null;
        deleteRootPostId = null;
        document.getElementById('delete-modal').classList.add('hidden');
    }

    async function confirmDelete() {
        if (!deletePostId) return;

        const token = localStorage.getItem('token');
        if (!token) return;

        try {
            const response = await fetch(`/api/posts/${deletePostId}`, {
                method: 'DELETE',
                headers: { 'Authorization': `Bearer ${token}` }
            });

            if (response.ok) {
                const wasComment = deleteRootPostId !== null;
                const rootId = deleteRootPostId;
                hideDeleteModal();

                if (wasComment && rootId) {
                    delete loadedComments[rootId];
                    await loadComments(rootId);
                    const countEl = document.getElementById(`comment-count-${rootId}`);
                    if (countEl) {
                        countEl.textContent = Math.max(0, parseInt(countEl.textContent) - 1);
                    }
                } else {
                    // Post itself was deleted, go back to feed
                    window.location.href = '/';
                }
            } else {
                const error = await response.json();
                alert(error.detail || 'Failed to delete');
            }
        } catch (e) {
            console.error('Failed to delete:', e);
            alert('Failed to delete');
        }
    }

    // Menus
    function toggleCommentMenu(commentId, event) {
        event.stopPropagation();
        document.querySelectorAll('[id^="comment-menu-"]').forEach(menu => {
            if (menu.id !== `comment-menu-${commentId}`) {
                menu.classList.add('hidden');
            }
        });
        const menu = document.getElementById(`comment-menu-${commentId}`);
        if (menu) {
            menu.classList.toggle('hidden');
        }
    }

    function closeCommentMenu(commentId) {
        const menu = document.getElementById(`comment-menu-${commentId}`);
        if (menu) {
            menu.classList.add('hidden');
        }
    }

    // Post menu functions (togglePostMenu, closePostMenu, sharePost) are provided by /static/js/posts.js
    // Close menus when clicking outside is also provided by /static/js/posts.js

    async function reportAbuse(postId) {
        const token = localStorage.getItem('token');
        if (!token) {
            window.location.href = '/login';
            return;
        }

        if (!confirm('Report this content for abuse? Our team will review it.')) {
            return;
        }

        try {
            const response = await fetch(`/api/posts/${postId}/report`, {
                method: 'POST',
                headers: { 'Authorization': `Bearer ${token}` }
            });

            if (response.ok) {
                alert('Report submitted. Thank you for helping keep JustPros clean.');
            } else {
                const error = await response.json();
                alert(error.detail || 'Failed to submit report');
            }
        } catch (e) {
            console.error('Failed to report:', e);
            alert('Failed to submit report');
        }
    }

    // ESC key to close modals
    document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
            document.querySelectorAll('[id^="comment-menu-"], [id^="post-menu-"]').forEach(menu => {
                menu.classList.add('hidden');
            });
            const imageModal = document.getElementById('image-modal');
            if (imageModal) {
                imageModal.remove();
            } else if (!document.getElementById('delete-modal').classList.contains('hidden')) {
                hideDeleteModal();
            }
        }
    });

    init();
</script>
{% endblock %}
